---
title: "Tables and Circle Plots comparing Naive and DRTMLE group differences"
author: "MB Nebel"
date: "10/30/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
#for tableby
library(arsenal)
library(xtable)
library(readxl)
library(circlize)
library(png)
#to remove background from .pngs
library(colordistance)
library(wesanderson)
```

#### Define Circle plot functions:
Based on https://drmowinckels.io/blog/2018-05-25-circluar-plots-in-r-and-adding-images/ and adapted by D Lidstone & B Risk
```{r}
#### Function to Make Transparent Colors 
t_col <- function(color, percent = 50, name = NULL) {
  #      color = color name
  #    percent = % transparency
  #       name = an optional name for the color
  
  ## Get RGB values for named color
  rgb.val <- col2rgb(color)
  
  ## Make new color using input color as base and alpha set by transparency
  t.col <- rgb(rgb.val[1], rgb.val[2], rgb.val[3],
               max = 255,
               alpha = (100 - percent) * 255 / 100,
               names = name)
  
  ## Save the color
  invisible(t.col)
}

# varname: a variable name corresponding to a column of results.ave
# thresh: threshold to use for displaying chords

myChordDiagram = function(data,varname,alpha=0.20,alphaname,title) {
  # alpha: pvalue threshold
  # alphaname: column of data with pvalues
  
  #
  
  ## Set transparent color, used to mask unwanted chords
  trcol <- t_col("white", perc = 100, name = "white")
  
  ## Set colors for negative and positive values
  poscol <- t_col("DodgerBlue4", perc = 15, name = "lt.blue") #positive correlation color
  negcol <- t_col("red", perc = 15, name = "lt.red") #negative correlation color
  
  ## Set names for networks (netLab)
  icInfo <- read_excel("componentLabels_pca85_ica30.xlsx")
  netLab <-icInfo$cognitive.domain[icInfo$signal==1]
  
  DATA = data.frame(images = list.files("ic_pngs_noBG",full.names = T), stringsAsFactors = F) %>% 
    mutate(
      names = gsub("[a-zA-Z]|[[:punct:]]","", images),
      values = sample(0:100, size=nrow(.), replace = T)
    )
  head(DATA)
  
  # Assign group in the original data frame
  DATA$Group = netLab %>% as.factor()
  
  nGroups = length(unique(DATA$Group))
  
  # Get colours, turn the vector into characters, and then use the factor numbers of DATA$Group to assign colour.
  
  cColors = wes_palette("FantasticFox1", nGroups, type = 'continuous')
  
  DATA$gColor = cColors %>% as.character %>% 
    .[as.numeric(DATA$Group)]
  
  #DATA$gColor = rainbow(nGroups) %>% as.character %>% 
   # .[as.numeric(DATA$Group)]
  
  #### arrange circle plot by group
  oDATA = DATA %>% arrange(Group)
  
  #### Define small gap between ICs and big gap between networks
  # sectorGap[1] is the gap after the first sector
  # sectorGap[end] should be bigGap
  
  smallGap = 1
  bigGap = 7
  sectorGap = rep(bigGap, nrow(DATA))
  
  for (ig in 1:nrow(DATA)-1){
    sectorGap[ig] = ifelse(oDATA$Group[ig+1]==oDATA$Group[ig], smallGap, bigGap)
  }
  
  ############################################
  # Create the weighted adjacency matrix:
  
  # Construct the "from" edge:
  ic.from =   substr(data$EdgeName,5,6)
  ic.from = ifelse(substr(ic.from,2,2)=='.',paste0('0',substr(ic.from,1,1)),ic.from)
  # visually check it looks good:
  cbind(data$EdgeName,ic.from)
  
  # Construct the "to" edge
  ic.to = substr(data$EdgeName,nchar(data$EdgeName)-1,nchar(data$EdgeName))
  ic.to = ifelse(substr(ic.to,1,1)=='c',paste0('0',substr(ic.to,2,2)),ic.to)
  # visually check it looks good:
  cbind(data$EdgeName,ic.to)
  
  # modify the THIRD variable to create chords for different variables:
  PAIRS = data.frame(ic.from,ic.to,data[,varname])
  
  #### Index specific pairs by a threshold
  
  neg_ix = data[,alphaname] < alpha & PAIRS[,3]<0
  pos_ix = data[,alphaname] < alpha & PAIRS[,3]>0
  
  cols = rep(trcol,nrow(PAIRS))
  cols[neg_ix]=negcol
  cols[pos_ix]=poscol
  
  ## Set plot background to white
  par(bg = 'white')
  
  ## 
  circos.par(gap.after = sectorGap)
  
  ##plot updated Chord diagram with new colors
  myPlot = chordDiagram(PAIRS, annotationTrack = c("grid"), 
                        annotationTrackHeight=c(0.05, 0.01), 
                        preAllocateTracks = list(track.height = 0.32), 
                        order=oDATA$names, grid.col = setNames(oDATA$gColor, oDATA$names), col=cols)
  title(title,col.main="black",cex.main=1.5)
  
  as_radians = function(x) x*pi/180
  
  ## Loop through images and plot brain maps
  u=0
  for(si in get.all.sector.index()){
    xplot=get.cell.meta.data("xplot",si)
    u=u+1
    
    # Small workaround because coordinate 0 should be 360
    if(xplot[1] == 0) xplot[1] = 360
    
    
    x=.86*cos(as_radians((xplot[2]+xplot[1])/2))
    y=.86*sin(as_radians((xplot[2]+xplot[1])/2))
    
    oDATA$images[grep(si, oDATA$images)] %>% 
      readPNG() %>% 
      rasterImage(x-0.09, y-0.09, x+0.09, y+0.09)
  }
  
  #### set labels to be black
  circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    xplot = get.cell.meta.data("xplot")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    circos.text(mean(xlim), ylim[1], sector.name, facing = "inside", 
                niceFacing = TRUE, adj = c(0.5, 0), col= "black")
  }, bg.border = NA)
  
  #    myPlot
}
```

#### Load results from two sets of 200 seeds
```{r}
results.all=NULL
for (i in 1:200) {
  load(paste0('../Results/Results_05October2021/ic30_pc85_glm_gam_drtmle_seed',i,'.RData'))
  results.all = rbind(results.all,results.df)
}
rm(results.df)

# second set of seeds:
results.all2=NULL
for (i in 201:400) {
  load(paste0('../Results/Results_05October2021/ic30_pc85_glm_gam_drtmle_seed',i,'.RData'))
  results.all2 = rbind(results.all2,results.df)
}
rm(results.df)

```

#### Average results from all seeds
```{r}
#SL = superlearner

results.ave = rbind(results.all,results.all2) %>%
  group_by(EdgeName) %>%
  summarize(mean.ASD.naive=mean(mean.ASD.naive), 
            mean.TD.naive=mean(mean.TD.naive),
            mean.diff.naive=mean(mean.diff.naive), 
            z.stat.ASD.naive=mean(z.stat.ASD.naive),
            z.stat.TD.naive=round(mean(z.stat.TD.naive), digits = 4),
            z.stat.diff.naive=round(mean(z.stat.diff.naive), digits = 4),
            mean.ASD.SL=round(mean(mean.ASD.SL), digits = 2), 
            mean.TD.SL=round(mean(mean.TD.SL), digits = 2),
            mean.diff.SL=round(mean(mean.diff.SL), digits = 2), 
            z.stat.ASD.SL=mean(z.stat.ASD.SL),
            z.stat.TD.SL=mean(z.stat.TD.SL), 
            z.stat.diff.SL=round(mean(z.stat.diff.SL), digits = 2))

results.ave$p.naive = 2*(1-pnorm(abs(results.ave$z.stat.diff.naive)))
results.ave$p.naive.fdr = round(p.adjust(results.ave$p.naive,method='BH'), digits = 3)
results.ave$p.SL = 2*(1-pnorm(abs(results.ave$z.stat.diff.SL)))
results.ave$p.SL.fdr = round(p.adjust(results.ave$p.SL,method='BH'), digits = 3)

```

#### Determin edges showing a significant group difference
```{r}
fdr05.edges.SL = which(results.ave$p.SL.fdr<.05) 
fdr05.edges.naive = which(results.ave$p.naive.fdr<.05) 

fdr20.edges.SL = which(results.ave$p.SL.fdr<.20) 
fdr20.edges.naive = which(results.ave$p.naive.fdr<.20) 

```

#### Remove background from .pngs of IC maps
```{r}
#create directory to save pngs with transparent background
dir.create("./ic_pngs_noBG")

DATA = data.frame(images = list.files("ic_pngs",full.names = T), stringsAsFactors = F) %>% 
    mutate(
      names = gsub("[a-zA-Z]|[[:punct:]]","", images),
      values = sample(0:100, size=nrow(.), replace = T)
    )
  head(DATA)

for(iimg in seq(1:nrow(DATA))) {
 img_data <- magick::image_read(DATA$images[iimg])
 new_img <- magick::image_transparent(img_data, 'black')
 fname <- sub('ic_pngs', 'ic_pngs_noBG', DATA$images[iimg])
 magick::image_write(new_img, fname)
}
  
```

#### Naive ASD-TD Z-Statistic FDR=0.05
```{r, fig.width=5, fig.height=5}
png("Application_Figures/Naive_zstat_groupdifference_fdr05.png",width=5,height=5,units="in",res=200)

myChordDiagram(data=results.ave,varname='z.stat.diff.naive',alpha=0.05,alphaname='p.naive.fdr', title='A. Naive Z-Statistic, ASD-TD')
dev.off()

circos.clear()

myChordDiagram(data=results.ave,varname='z.stat.diff.naive',alpha=0.05,alphaname='p.naive.fdr',title='A. Naive Z-Statistic, ASD-TD, FDR=0.05')

circos.clear()

```

#### DRTMLE ASD-TD Z-Statistic FDR=0.05
```{r, fig.width=5, fig.height=5}

png("Application_Figures/DRTMLE_zstat_groupdifference_fdr05.png",width=5,height=5,units="in",res=200)
myChordDiagram(data=results.ave,varname='z.stat.diff.SL',alpha=0.05,alphaname='p.SL.fdr',title='B. DRTMLE Z-Statistic, ASD-TD')
dev.off()

circos.clear()

myChordDiagram(data=results.ave,varname='z.stat.diff.SL',alpha=0.05,alphaname='p.SL.fdr',title='B. DRTMLE Z-Statistic, ASD-TD, FDR=0.05')

circos.clear()

```

#### Create table displaying group Z-statistics from DRTMLE for edges showing a group difference at FDR=.20
```{r, results="asis"}
# group means for edges showing a group difference using DRTMLE:
results.sigEdges = results.ave[fdr20.edges.SL,c(1,8:9,13,15, 17)]

results.sigEdges <-   results.sigEdges[order(results.sigEdges$p.SL.fdr), ]

names(results.sigEdges)[1] = "Edge"
names(results.sigEdges)[2] = "ASD mean"
names(results.sigEdges)[3] = "TD mean"
names(results.sigEdges)[4] = "ASD-TD Z"
names(results.sigEdges)[5] = "naive FDR-adjusted p"
names(results.sigEdges)[6] = "SL FDR-adjusted p"


knitr::kable(results.sigEdges, format="markdown")

```

DRTMLE indicates a significant deconfounded group difference for the first four edges at the FDR=.05 level and an additional seven edges at the FDR=.20 level.

Mean functional connectivity group estimates further from zero reflect stronger functional connectivity regardless of sign; positive scores reflect positive partial correlations, or more integrated intrinsic activity between independent components (ICs). Negative scores reflect negative partial correlations, or more segregated intrinsic activity between ICs.

#### Create latex version for paper
```{r}
tab <- knitr::kable(results.sigEdges, format="latex")
print(tab, type="latex")

```

#### Naive ASD-TD Z-Statistic FDR=0.20
```{r, fig.width=5, fig.height=5}

png("Application_Figures/Naive_zstat_groupdifference_fdr20.png",width=5,height=5,units="in",res=200)
myChordDiagram(data=results.ave,varname='z.stat.diff.naive',alpha=0.20,alphaname='p.naive.fdr', title='A. Naive Z-Statistic, ASD-TD')
dev.off()

circos.clear()

myChordDiagram(data=results.ave,varname='z.stat.diff.naive',alpha=0.20,alphaname='p.naive.fdr',title='A. Naive Z-Statistic, ASD-TD, FDR=0.20')

circos.clear()


```

#### DRTMLE ASD-TD Z-Statistic FDR=0.20
```{r, fig.width=5, fig.height=5}

png("Application_Figures/DRTMLE_zstat_groupdifference_fdr20.png",width=5,height=5,units="in",res=200)
myChordDiagram(data=results.ave,varname='z.stat.diff.SL',alpha=0.20,alphaname='p.SL.fdr',title='B. DRTMLE Z-Statistic, ASD-TD')
dev.off()

circos.clear()

myChordDiagram(data=results.ave,varname='z.stat.diff.SL',alpha=0.20,alphaname='p.SL.fdr',title='B. DRTMLE Z-Statistic, ASD-TD, FDR=0.02')

circos.clear()

```

